---
layout: post
title: iOS.Core.Animation笔记一.Layer
---

![image](/AllenChiangBlog/public/upload/2014-05-04-cover_of_iOS.Core.Animation.png)

Nick Lockwood的《iOS Core Animation》全书分为3大部分

1. The Layer Beneath
2. Setting Things in Motion
3. The Performance of a Lifetime

本文章篇幅限定对第一部分Layer的摘记，后续部分可能会继续整理。


Core Animation并不只是包含动画，其实动画只是他的一部分，更合适的名称应该是Layer Kit。

## 1.The Layer Tree

凡是开发过iOS或者Mac OS应用的同学都应该知道view的概念。view是一个矩形的用于显示内容（比如图像，文字，视频等）的对象。
在iOS中，所有的view都继承自UIView。UIView可以控制用户事件并且支持Core Graphic绘图，仿射变换（例如旋转和拉伸），以及简单的动画比如滑动和渐隐。
同时你可能已经发现了UIView并不是他自己处理了这一切，其实绘图，布局和动画都是由CALayer来控制的。

### CALayer

CALayer和UIView非常类似，最主要去区别就是CALayer不处理用户交互行为，也就是说CALayer并不能感知[responder chain](https://developer.apple.com/library/iOs/documentation/EventHandling/Conceptual/EventHandlingiPhoneOS/event_delivery_responder_chain/event_delivery_responder_chain.html)的存在所以他不能响应用户交互的事件，但他也用于对交互行为触发位置的落点判断。

我们为什么要了解CALayer的存在，因为他有一些UIView不能做的事情：

1. 阴影、圆角、多彩的border

2. 3D变化和定位

3. 非矩形的边界

4. alpha遮罩

5. 多步非线性动画

## 2. The Backing Image

### contents

CALayer的contents属性的类型是id，主要是为了同时支持Mac OS和iOS，在Mac OS下contents可以被设置为NSImage，在iOS下则需要设置为CGImageRef。当然如果你设置其他类型的值，则CALayer会显示为空白。

### contentsGravity

当图片大小不是适合当前view的时候，你可能会使用view.contentMode来设置缩放和位置，其实他是通过控制CALayer的contentGravity属性来实现的

	kCAGravityCenter 			kCAGravityTop
	kCAGravityBottom 			kCAGravityLeft
	kCAGravityRight 			kCAGravityTopLeft
	kCAGravityTopRight 			kCAGravityBottomLeft
	kCAGravityBottomRight 		kCAGravityResize 
	kCAGravityResizeAspect 		kCAGravityResizeAspectFill

例如我们可以使用类似于UIViewContentModeScaleAspectFit的kCAGravityResizeAspect来设置我们的图片拉伸以适应我们layer的bounds
	self.layerView.layer.contentsGravity = kCAGravityResizeAspect;
### contentScale
contentScale用来定义像素尺寸到layer尺寸的拉伸比率，默认值是1。如果你设置了上面的contentsGravity属性，则contentScale很可能是没有效果的。
其实contentScale多用于设置高分辨率屏幕下的图片尺寸，如果=1则表示每个点代表一个像素，如果=2则表示每个点代表两个像素。因为layer的contents支持的CGImage并不知道当前分辨率的情况（UIImage支持），所以需要配合contentScale属性来支持合适的图片尺寸。以下两种方式设置contentScale都可以：

	//1.set the contentsScale to match image	self.layerView.layer.contentsScale = image.scale;

	//2.set the screen scale 	self.layerView.layer.contentsScale = [UIScreen mainScreen].scale;
### contentsRect
允许我们定义content image的一部分矩形区域用于当前layer的显示，默认值是{0,0,1,1}表示显示全部。
不同于bounds、frame通过point来度量大小，contentsRect使用的是Unit坐标。在iOS中常见3各种坐标度量：

* Points -- 在非高清屏幕设备中，1point=1像素；高清屏幕设备中，1point=2像素。iOS用这种坐标来统一高清和非高清的设备坐标尺寸。

* Pixels -- CGImage使用Pixels坐标，所以要主要CGImage不适应高清屏幕显示。


* Unit -- 这种坐标更方便的用于指定相对大小，多用于OpenGL和Core Animation。


举例如{0,0,0.5,0.5}表示只显示contents的左上角四分之一,{0.5,0,0.5,0.5}表示只显示contents的右上角的四分之一，其他同理可得。

### contentsCenter

contentsCenter定义了layer内部一个可以被拉伸的区域，外部则是一个固定的边界。同时他使用的也是跟上面contentsRect一样的Unit坐标表示法。

![image](/AllenChiangBlog/public/upload/2014-05-04-contentsCenter.png)

如上图所示就比较清晰了，定义了contentsCenter={0.25,0.25,0.5,0.5}，则表示中间绿色区域都是可以被拉伸的，蓝色区域可以被横向拉伸纵向则固定宽度，红色区域反之是纵向可以被拉伸横向宽度固定。

### 自定义绘图方法-drawRect: & -displayLayer:

你可能已经知道在UIView的子类中可以通过实现-drawRect:方法来自定义绘图。根据apple的建议如果你不需要自定义绘图请不要实现一个空的该方法，以浪费不必要的系统开销。因为UIView一旦发现有-drawRect:方法实现，系统就会自动为他创建一个像素背景尺寸乘以contentScale大小的图像。

CALayer的自定义绘图则通过layer的delegate对象（CALayerDelegate 协议）的以下两个方法来实现


	// 方法1
	- (void)displayLayer:(CALayerCALayer *)layer;
	
	// 方法2. 如果方法1没有实现，则调方法2
	- (void)drawLayer:(CALayer *)layer inContext:(CGContextRef)ctx;
	
和UIView的-drawRect: 不同的两点需要注意

* 开发者需要手动调用CALayer的-display:方法来触发layer的绘制

* 通过CALayerDelegate自定义绘图方法绘制的图像不会超出边界，类似UIView的masksToBounds=YES的效果


## 3. Layer Geometry

UIView有3个最主要的布局属性：frame、bounds和center，CALayer也有相对应的属性：frame、bounds和position。
frame其实是layer在父layer中的坐标，bounds是自己内部的坐标（左上角为{0,0}原点），frame反映了layer在父layer中轴向坐标下占用的矩形区域。下图显示了一个经过旋转以后的矩形view或者layer的frame、bounds以及center和position。

![image](/AllenChiangBlog/public/upload/2014-05-04-frame&bound.png)

center和position都是anchorPoint（锚点）相对于父layer的坐标。默认情况下，anchorPoint总是位于矩形区域的中间点，在view中不出现anchorPoint，意味着不能移动anchorPoint，所以view中名称就是center。而layer中anchorPoint可以移动，比如你可以把anchorPoint移动到当前layer的左上角{0,0}（anchorPoint用的也是unit坐标，默认中间点{0.5,0.5}），这时由于position保持不变，layer会相对父layer往右下角移动

![image](/AllenChiangBlog/public/upload/2014-05-04-anchor-point.png)

### 坐标系统

CALayer提供若干工具方法用于转换相对于不同layer的坐标


	- (CGPoint)convertPoint:(CGPoint)point fromLayer:(CALayer *)layer;
	- (CGPoint)convertPoint:(CGPoint)point toLayer:(CALayer *)layer; 
	- (CGRect)convertRect:(CGRect)rect fromLayer:(CALayer *)layer;
	- (CGRect)convertRect:(CGRect)rect toLayer:(CALayer *)layer;
	
### Flipped Geometry

在iOS中采用的是左上角为原点的坐标，而Mac OS中采用的坐下家为原点的坐标。Core Animation通过geometryFlipped属性来支持上述两种坐标体系的转换。如果geometryFlipped属性为YES，则表示当前layer相对于父layer坐标进行几何垂直翻转。

### The Z Axis

不同于UIView的二维坐标，CALayer通过zPosition和anchorPointZ两个float属性提供三维坐标空间。zPosition值越大越显示在上面。

### Hit Testing

虽然CALayer不感知responder chain，但是他通过提供-containPoint:和-hitTest:两个方法来帮助你定位事件所在layer。
另外CALayer对自动布局缺乏支持，建议使用UIView。


## 4. Visual EFfects

### Rounded Corners 圆角

CALayer有一个cornerRadius属性用来制作layer的圆角，值表示圆弧的半径，单位是上面提到过3种单位中的point，他可以被设置为任何的float数字（default=0）。默认情况下该属性只作用于backgroundColor，而对于sublayer和背景图都没有效果，但是如果配合masksToBounds=YES的设置，可以对layer内所有元素生效。

### Layer Border 边框

CALayer通过borderWidth和borderColor两个属性的组合来定义border的宽度和颜色。
borderWidth用float的point度量定义了boder笔画的粗细。

borderColor的类型是CGColorRef，而不是UIColor；他同时会retain传给他的这个CGColorRef。

border位于bounds范围内，而且位于所有的子layer之上。不管内容是什么形状或者是否超出当前layer的bounds，border总是沿着bounds。

### Drop Shadows 阴影

通过设置shadowOpacity属性为一个大于0的值，可以给任意layer添加一个背景阴影。取值范围是0.0到1.0，表示全透明到非透明。同时还可以通过shadowColor、shadowOffset和shadowRadius三个属性来修改阴影的外观。

shadowColor同borderColor和backgroundColor类似用于修改阴影的颜色，默认是黑色。

shadowOffset是一个CGSize类型，控制了阴影的距离和方向。默认值是{0,-3}，是的默认值下阴影位于layer的上部，因为这个属性最早用于Mac OS，而Mac OS的坐标系和iOS是相反的。

shadowRadius控制阴影的模糊度，值越大越模糊。通常我们使用较大的值来制造一种比较大的视觉深度。

### Shadow Clipping 阴影裁切

不同于border围绕在layer的bounds，shadow是围绕在真正的内容外。正是由于他围绕在真正内容的外面，如果他超过bounds时，会被masksToBounds给裁切掉，通常这不是我们想要的效果。

如果你既想要裁切多余的内容，同时又显示阴影，这时候你就需要两个重叠的layer，一个masksToBounds=YES，另外一个则=NO同时设置想要的阴影外观

### shadowPath 阴影路径

由于需要结合所有子layer画出边界外的阴影，所以shadow方法其实会有性能上的隐患；shadowPath正是为了解决性能问题而推出的，可以给开发者手动设置阴影的路径。

shadowPath可以接受CGPathRef类型的值，你可以通过CGPath开头的很多CoreGraphic方法绘制自己想要的阴影图形。

### Layer Masking 遮罩

mask属性接受另外一个CALayer值，可以被用作将当前layer裁切成给定layer的轮廓。

### Scaling Filters 缩放方式

minificationFilter 用于指定缩小的方式

magnificationFilter 用于指定放大的方式

可用的值均是

	kCAFilterLinear
	kCAFilterNearest
	kCAFilterTrilinear
	
### Group Opacity 

我们通常使用UIView的alpha属性来设置view的透明度，如果在CALayer中我们同样会使用opacity来设置，这2个属性同样会作用于他得所有subView和subLayer。

但是如果是一个有sublayer的control可能会出现下图这样的情况

![image](/AllenChiangBlog/public/upload/2014-05-04-group-opacity.png)

这主要是由于helloword所在层也被设置了opacity（假设opacity=0.5），和后面的control的opacity叠加，所以你看到的中间部分其实是0.5*0.5+0.5=0.75。

通常这不是我们想要的效果，我们通常有2种方法来处理：

1. 在app的Info.plist中添加UIViewGroupOpacity=YES。这会作用于当前app下得所有所有范围，可能还有点小的性能浪费。
2. 通过CALayer的 shouldRasterize=YES，将layer及其子layer全部打散成一个平面的图形，再使Opacity生效就可以达到我们想要的效果了。由于rasterizationScale默认等于1.0，会使得高清屏幕下图片像素化，所以我们还要同时设置一下

	layer.rasterizationScale = [[UIScreen mainScreen] scale];
	

## 5. Transforms

### Affine Transforms 仿射变换

UIView的transform属性类型是CGAffineTransform，他是用于对view进行二维空间下的旋转、拉伸或变形。CGAffineTransform其实是一个2列3行的矩阵，被用于乘以一个二维的行向量（当前情况下是CGPoint），来实现变换。但是实际上你会经常看到二维变换是一个3x3的矩阵。

![image](/AllenChiangBlog/public/upload/2014-05-040-transform.png)

仿射变换的限制是无论如何变换，变换之前平行的两条线，变换后仍然平行，比如下图前3个变换都是仿射变换，而最后一个就不是仿射变化，明显竖线上述条件。

![image](/AllenChiangBlog/public/upload/2014-05-04-affinetransform.png)

Core Graphics提供创建仿射变化的快捷方法

	// 这里的angle是弧度，通常使用的如：M_PI_4/M_PI
	CGAffineTransformMakeRotation(CGFloat angle)
	
	CGAffineTransformMakeScale(CGFloat sx, CGFloat sy)
	
	CGAffineTransformMakeTranslation(CGFloat tx, CGFloat ty)
	
	// 角度和弧度相互转换的宏
	#define RADIANS_TO_DEGREES(x) ((x)/M_PI*180.0)
	
	#define DEGREES_TO_RADIANS(x) ((x)/180.0*M_PI)
	
UIView可以通过transform属性来实现变换，其实他就是对CALayer的封装。

CALayer同时也有一个transform属性，不过他的类型不是CAAffineTransform，而是CATransform3D。CALayer实现仿射变化的属性是affineTransform。

### Combining Transforms

Core Graphics同时提供了在一个transform上合并另外一个的方法。

	CGAffineTransformRotate(CGAffineTransform t, CGFloat angle) 
	
	CGAffineTransformScale(CGAffineTransform t, CGFloat sx, CGFloat sy) 
	
	CGAffineTransformTranslate(CGAffineTransform t, CGFloat tx, CGFloat ty)
	
首先你需要创建一个恒等变换：

	CGAffineTransformIdentity

使用下面方法组合两个不同的变换

	CGAffineTransformConcat(CGAffineTransform t1, CGAffineTransform t2);
	
另外以顺序组合变换，前一个变换会影响到下一个变换，比如如下代码：

	//create a new transform
	CGAffineTransform transform = CGAffineTransformIdentity; //scale by 50%
	transform = CGAffineTransformScale(transform, 0.5, 0.5); //rotate by 30 degrees
	
	//translate by 200 points
	transform = CGAffineTransformRotate(transform, M_PI / 180.0 * 30.0); 
	
	transform = CGAffineTransformTranslate(transform, 200, 0);

	//apply transform to layer	
	self.layerView.layer.affineTransform = transform;
	
### Shear Transform

虽然官方没有提供这种变换的方法，但是我们仍然可以通过修改transform的a,b,c,d几个参数来实现

### 3D Transforms

跟仿射变换的3x3矩阵不同，CATransform3D是一个4x4的矩阵，从而支持了对于垂直屏幕的z轴的变换效果。

	CATransform3DMakeRotation(CGFloat angle, CGFloat x, CGFloat y, CGFloat z) 
	CATransform3DMakeScale(CGFloat sx, CGFloat sy, CGFloat sz) 
	CATransform3DMakeTranslation(Gloat tx, CGFloat ty, CGFloat tz)

和上面2D的方法有点类似，只是多了一个z的参数，另外旋转方法多了3个x，y，z的参数来表示旋转针对哪个轴。（大于0即可，如果同时有多个值大于0会怎么旋转，回头试试看 lol）

![image](/AllenChiangBlog/public/upload/2014-05-04-3dtransform.png)

如上图所示，环绕z轴的旋转其实就是我们上面提到过的2D旋转，而环绕x，y轴的旋转则使得layer离开了屏幕所在的2维屏幕。
如果只是y轴的旋转，可能会让你看起来似乎只是对layer做了横向的压缩。其实他看起来不对的原因是没有做perspective（景深？）。

(未完待续)